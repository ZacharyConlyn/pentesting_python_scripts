#!/usr/bin/env python3

# This version is improved from the book's.
# It can be fed an /etc/shadow file from a
# modern Linux distro. Tested on Ubuntu 16.04.

import itertools
from concurrent.futures import ThreadPoolExecutor
import crypt
import argparse
from datetime import datetime
from helper_functions import lazy_load

# constants
MAX_WORKERS = 8
PASS_CHUNK_SIZE = 1000

uncracked_users = []


def test_pass(word: str) -> None:
    global uncracked_users
    for item in uncracked_users:
        created_hash = crypt.crypt(word, item["salt"])
        if created_hash == item["hash"]:
            print(f"\n[+] User: {item['user']}, password: {word}")
            uncracked_users.remove(item)



#def test_pass(crypt_pass: str) -> None:
#
#    split_pass = crypt_pass.split("$")
#    if len(split_pass) != 4:
#        print("[-] Format of password field is weird.")
#        return
#    salt = "$".join(split_pass[:3])
#    try:
#        with open("dictionary.txt", "r") as dict_file:
#            for word in dict_file.readlines():
#                word = word.strip("\n")
#                crypt_word = crypt.crypt(word, salt)
#                if crypt_word == crypt_pass:
#                    print(f"[+] Found Password: {word}")
#                    return
#    except FileNotFoundError as err:
#        print(f"[-] {err}")
#    print("[-] Passowrd not found.")
#    return
#








def main():
    global uncracked_users
    # for each entry in dict file:
        # send to test_pass

    # get shadow file and dict file
    parser = argparse.ArgumentParser()
    optional = parser._action_groups.pop()
    required = parser.add_argument_group("required arguments")
    optional = parser.add_argument_group("optional arguments")
    required.add_argument("-f", "--file", type=str, help="shadow-like file to crack", required=True)
    required.add_argument("-d", "--dictionary", type=str, help="dictionary file to use", required=True)
    args = parser.parse_args()

    # parse shadow file
    start_time = datetime.now()
    with open(args.file, "r") as shadow_file:
        for line in shadow_file:
            if ":" in line:
                user = line.split(":")[0]
                hash_ = line.split(":")[1].strip(" ")
                split_hash = hash_.split("$")
                if len(split_hash) == 4:
                    print(f"Adding user to list: {user}, hash: {hash_}")
                    user_dict = {"user": user, "hash": hash_, "salt": "$".join(split_hash[:3])}
                    uncracked_users.append(user_dict)
    if not uncracked_users:
        print("[-] No valid users/hashes found in file. Is it in the correct format?")
        exit(-1)

    passwords_tried = 0
    try:
        with open(args.dictionary, "r", errors="ignore") as dict_file:
            generator = lazy_load(dict_file)
            next_list = [word for word in itertools.islice(generator, PASS_CHUNK_SIZE)]
            while next_list:
                with ThreadPoolExecutor(max_workers=MAX_WORKERS) as tp_exec:
                    for word in next_list:
                        if not uncracked_users:
                            elapsed_time = (datetime.now() - start_time)
                            hours, minutes, seconds = str(elapsed_time).split(":")
                            hours = str(int(hours))
                            minutes = str(int(minutes))
                            seconds = str(round(float(seconds)))
                            print(f"[+] All users cracked in {hours} hours, {minutes} minutes, and {seconds} seconds.")
                            exit(0)
                        passwords_tried += 1
                        tp_exec.submit(test_pass, word)
                    tp_exec.shutdown(wait=True)
                if uncracked_users:
                    next_list = [word for word in itertools.islice(generator, PASS_CHUNK_SIZE)]
                    print(f"\rPasswords tried: {passwords_tried}, uncracked users left: {len(uncracked_users)}", end="")
            if uncracked_users:
                final_uncracked_users = ", ".join(item["user"] for item in uncracked_users)
            print(f"\n[-] Could not find a password for user(s) {final_uncracked_users}")
    except FileNotFoundError as err:
        print(f"[-] {err}")














if __name__ == "__main__":
    main()
