#!/usr/bin/env python3

# This version is improved from the book's.
# It can be fed an /etc/shadow file from a
# modern Linux distro. It's also multithreaded.

import itertools
from concurrent.futures import ThreadPoolExecutor
import crypt
import argparse
from datetime import datetime
from helper_functions import lazy_load

# constants; change these to optimize performance in your setting
MAX_WORKERS = 1
PASS_CHUNK_SIZE = 500

# a global (yikes!) for users we haven't cracked yet

def test_pass(word: str, uncracked_users: list) -> None:
    for user in uncracked_users:
        created_hash = crypt.crypt(word, user["salt"])
        if created_hash == user["hash"]:
            uncracked_users.remove(user)
            print(f"\n[+] Found user:pass -- {user['name']}:{word}")

def main():
    parser = argparse.ArgumentParser()
    optional = parser._action_groups.pop()
    required = parser.add_argument_group("required arguments")
    optional = parser.add_argument_group("optional arguments")
    required.add_argument("-f", "--file", type=str, help="shadow-like file to crack", required=True)
    required.add_argument("-d", "--dictionary", type=str, help="dictionary file to use", required=True)
    args = parser.parse_args()

    start_time = datetime.now()

    # parse shadow file and add the users to the list uncracked_users
    uncracked_users = []
    with open(args.file, "r") as shadow_file:
        for line in shadow_file:
            if ":" in line:
                username = line.split(":")[0]
                hash_ = line.split(":")[1].strip(" ")
                split_hash = hash_.split("$")
                if len(split_hash) == 4:
                    print(f"[*] {username}:{hash_}")
                    user_dict = {"name": username, "hash": hash_, "salt": "$".join(split_hash[:3])}
                    uncracked_users.append(user_dict)
    if not uncracked_users:
        print("[-] No valid users/hashes found in file. Is it in the correct format?")
        exit(-1)

    passwords_tried = 0
    try:
        with open(args.dictionary, "r", errors="ignore") as dict_file:
            # load up the next PASS_CHUNK_SIZE passwords to try
            generator = lazy_load(dict_file)
            next_list = [word for word in itertools.islice(generator, PASS_CHUNK_SIZE)]
            while next_list:
                with ThreadPoolExecutor(max_workers=MAX_WORKERS) as tp_exec:
                    for word in next_list:
                        if not uncracked_users:  # we're done
                            exit(0)
                        passwords_tried += 1
                        tp_exec.submit(test_pass, word, uncracked_users)
                    tp_exec.shutdown(wait=True)
                if uncracked_users:
                    delta = datetime.now() - start_time
                    elapsed_seconds = delta.total_seconds()
                    print(f"\r[*] Passwords tried: {passwords_tried} in {round(elapsed_seconds)} "
                            f"seconds (avg {round(passwords_tried/elapsed_seconds)}/sec), uncracked "
                            f"users left: {len(uncracked_users)}", end="")
                    next_list = [word for word in itertools.islice(generator, PASS_CHUNK_SIZE)]
            if uncracked_users:
                final_uncracked_users = ", ".join(item["name"] for item in uncracked_users)
            print(f"\n[-] Could not find a password for user(s) {final_uncracked_users}")
    except FileNotFoundError as err:
        print(f"[-] {err}")


if __name__ == "__main__":
    main()
