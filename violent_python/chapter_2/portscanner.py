#!/usr/bin/env python3

import argparse
import socket as s
from threading import Thread, Lock, Timer
import concurrent.futures

BUFF_LEN = 128

lock = Lock()

def t_print(*args, **kwargs):
    with lock:
        print(*args, **kwargs)

def conn_scan(target_host, target_port):
    try:
        conn_sock = s.socket(s.AF_INET, s.SOCK_STREAM)
        conn_sock.connect((target_host, target_port))
        conn_sock.send("vi013nt_pyth0n".encode())
        results = conn_sock.recv(BUFF_LEN)
        t_print(f"[+] {target_port}/TCP open: {results.decode('utf-8').rstrip()}")
        conn_sock.close()
    except ConnectionRefusedError:
        t_print(f"[-] {target_port}/TCP closed")
    except s.timeout:
        t_print(f"[-] {target_port}/TCP timed out")
    


def port_scan(target_host, target_ports):
    try:
        target_ip = s.gethostbyname(target_host)
    except exception as ex:
        t_print(f"[-] {ex}")

    try:
        target_name = s.gethostbyaddr(target_ip)
        t_print(f"\n[+] Scan results for {target_name[0]}:")
    except Exception as ex:
        t_print("\n[+] Scan results for {target_ip}")
    s.setdefaulttimeout(1)
    with concurrent.futures.ThreadPoolExecutor(max_workers=100) as executor:
        futures = []
        for port in target_ports:
            futures.append(executor.submit(conn_scan, target_host, int(port)))


def main():
    parser = argparse.ArgumentParser()
    optional = parser._action_groups.pop()
    required = parser.add_argument_group("required arguments")
    optional = parser.add_argument_group("optional arguments")
    required.add_argument("-H", "--host", type=str, help="target host", required=True)
    required.add_argument("-p", "--ports", type=str, help="target port(s) separated by commas", required = True)
    args = parser.parse_args()

    target_host = args.host
    target_ports = args.ports.split(",")
    port_scan(target_host, target_ports)


if __name__ == "__main__":
    main()



